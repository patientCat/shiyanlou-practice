# 线程池系统学习
## 工作背景
对于网络中一个请求，我们按其总共要求的服务器处理的时间可以将其分为长请求和短请求。有些请求非常短，
如果我们直接交由处理器去完成，则需要创建线程，线程执行任务和销毁线程三个阶段。在高并发的时候，这是非常
笨的方法。为此我们需要事先创建线程池，并创建一定数量的线程，当任务到达后，从队列中提取并执行。执行完成
后，线程并不销毁，而是等待下一任务的到来。为此我们甚至可以专门设置处理某一类任务的线程。比如专门负责
处理下载等长请求的线程等等。
## 基本组成
1. 线程池（ThreadPool）:负责创建，管理线程池，最基本的操作为：创建线程池、销毁线程池、增加新的线程任务
2. 工作线程（Worker）：线程池中的线程，在没有任务时会处于等待状态，可以循环执行任务
3. 任务队列（Tasks Queue）：未处理任务的缓存队列

## lambda表达式
又称之为闭包或者匿名函数。<br/>
`[捕获列表](参数列表)mutable(可选)异常熟悉 -> 返回类型{
    // 函数体
}`<br/>
其它方面都很熟悉了，这里就单单对捕获列表重新复习下。<br/> 
```cpp
手工方式
[]空捕获列表
值捕获[value]
引用捕获[&value]

自动推推导的方式
[&]
[=]
```


```cpp
void test0()
{
    int val1 = 1;
    int val2 = 2;
    auto lambda = [&](){
        ++val1; ++val2; }; // val1 = 2, val2 = 3; 
    reset(val1, val2);
    auto lambda1 = [=](){
        ++val1; ++val2; }; // val1 = 1, val2 = 2;
    reset(val1, val2);
    auto lambda2 = [=, &val2](){ // error lambda默认是pass by const value 传递，通过添加mutable选项行
        ++val1; ++val2; };
    reset(val1, val2);
    auto lambda3 = [=, &val2]()mutable{ // val1 = 1, val2 = 3;
        ++val1; ++val2; };
    auto lambda4 = [&, val2]()mutable{ // 和上面同理
        ++val1; ++val2; };
}
```

## C++11并行编程
已经存在部分网络库了。 
